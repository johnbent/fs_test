import os,sys,time,getpass
sys.path += [ './lib', '../lib' ]
import fs_test,expr_mgmt
#
# A simple example of how this experiment management framework is used.  Edit
# to run parameter sweeps on the mpi job of your choice with or without msub.
# You need to edit mpi_options{} which is a dictionary of option flags mapping to
# arrays of options (e.g. "np" : [100, 200]).  You need to set the path to your
# mpi program.  You need to also edit program_options{} which is analogous to
# mpi_options{} and you need to edit program_arguments[] which is an array of
# arrays for the required arguments to your program.  mpi_options{} and
# program_options{} can be None.  
# 
# Here are a couple of ways to create python arrays: 
# [ item, item ],
# range(1,32,2), 
# "item item item".split(). 

#
# Sometimes you may want little helper Python variables.
#
user     = getpass.getuser()
home     = os.getenv( "HOME" )
mpi_host = os.getenv( "MY_MPI_HOST" )
#
# Tell where the fs_test program is sitting.
#
mpi_program = ( "%s/path/to/fs_test/fs_test-%s.x" % ( home, mpi_host )) 
#
# fs_test needs a place to create temporary file.
#
tmp_dir = ( "%s/path/to/tmp-%s" % ( home, mpi_host ))
#
# The targets of fs_test.
#
target_dirs = [ "/path/to/file-system/target_dir0", "/path/to/file-system/target_dirn" ]
#
# Setup the MPI options you want to pass to the MPI launching program, for
# example, "mpirun" or "aprun".
#
mpi_options = {
#  "N"     : [ pe-count-per-node-1, ..., pe-count-per-node-a ],
#  "n"    : [ pe-count-1, ..., pe-count-b ],
#  "np"    : [ pe-count-1, ..., pe-count-c ],
}
#
# fs_test options
#
# In all cases, the options can be lists. The parsing program will generate
# fs_test commands one at a time by picking the first element of each list.
# The next command will be generated by going to the next element of the last
# list that has multiple entries, etc.
#
# Of course, the "mpi_options" above are the first lists.
#
program_options = {
#
# The target of the test.
#
# The "%s" substitutes the string argument in parentheses, target_dir1
# and target_dirn.
#
# The "%%s" substitutes a timestamp value when the program is run that helps
# to make unique filenames.
#
# For N-N runs, the rank of the process creating the file is always appended
# to the rest of the filename specified here.
#
  "target"   : [ "%s/out.%%s" % ( target_dirs[0] ), "%s/out.%%s" % ( target_dirs[1] ) ],
#
# The size of the data element to be written and/or read.
#
  "size"     : [ "48M" ],
#
# Set a maximum file size as an exit condition. Can be used with the "time"
# option so that the files don't get too big.
#
#  "maxsize"  : [ "48G" ],
#
# Set the maximum offset in a file so that I/Os wrap if it gets too large.
#
#  "maxoff"   : [ "18G" ],
#
# The amount of time to write or read. The timed experiment can create files
# of an undetermined size. It's all based on the size, the amount of time,
# and the performance of the target.
#
  "time"     : [ 300 ],
#
# Instead of time to read or write, the user may specify the number of "size"
# elements to write and/or read. This makes a fixed-size file operation.
#
#  "nobj"    : [ 40 ],
#
# If the experiment is an N-1 segmented write then this parameter tells how
# many "size" elements go in each section. This way each process knows the
# offset into the shared file where it starts to write when the experiment
# is timed. Once the segment is filled, it goes to the end of the file and
# starts a new segment.
#
#  "supersize"  : [ '1024' ],
#
# Makes it so that the process doing the read does not read the same data it
# wrote. Where possible, it will read from a file written by a process on a
# different node. This makes it so that read performance results aren't
# enhanced by data that is cached.
#
  "shift"    : [ '' ],
#
# This parameter can be 0, 1, 2, 3, or not provided. If 0 or not provided
# there is no specific value that is written to the file. If 1 a known
# value is written to the first byte of each block. If 2 a known value is
# written to the first byte of each page. If 3 a known value is written
# to every byte.
#
#  "touch"    : [ 0 ],
#
# This parameter can be 0, 1, 2, 3, or not provided. Based on the value
# the read does not or does check for the known value at the given
# location. If it does check, those are:
#
# 1 = first byte of block
# 2 = first byte of page
# 3 = all bytes
#
#  "check"    : [ 0 ],
#
# Tells whether or not to delete the file(s) after the experiment is run.
#
#  "deletefile" : [ '' ],
#
# Tells whether or not to truncate the file after the experiment is run.
#
#  "truncatefile" : [ '' ],
#
# Gives the experiment a name that can be used to identify a test sequence
# that is stored in a database, for example.
#
#  "experiment" : [ 'Test-name-without-spaces.' + str(int(time.time())) ],
#
# Tells which fs_test events require a barrier. A barrier is where each
# process waits for all processes to reach that point before moving on.
# Barriers are comma-separated, for example, 'bopen,aopen'. Possible barriers
# are:
#
# bopen - Before opening files.
# aopen - After opening files.
# bwrite - Before starting to write files.
# awrite - After finishing to read files.
# bread - Before starting to read files.
# aread - After finishing to read files.
# bclose - Before closing files.
# bsync - During close process, before syncing files after writing.
# async - During close process, after syncing files after writing.
# btrunc - During close process, before truncating files for N-N I/O
# atrunc - During close process, after truncating files for N-N I/O
# bstat - During the close process, before stating files before they are closed.
# astat - During the close process, after stating files before they are closed.
# aclose - After closing files.
#
  "barriers"   : [ 'aopen' ],
#
# The type of I/O that is to be done in the experiment. Possible values
# are:
#
# mpi - MPI/IO
# posix - POSIX I/O
# plfs - PLFS API for doing I/O
#
  "io"     : [ 'mpi' ],
#
# This is only used if the "io" is 'plfs'. If non-zero it tells PLFS to
# flatten the index file for better performance.
#
#  "flatten"    : [ 1 ],
#
# The I/O operations to do. If not provided the default is to write and then
# read. Possible values are:
#
# write - Only write files.
# read - Only read files.
#
#  "op"        : [ 'write' ],
#
# If provided it tells fs_test to sync the file to disk afte writing.
#
  "sync"     : [ '' ],
#
# The directory into which fs_test should write its temporary files.
#
  "tmpdirname" : [ "%s" % tmp_dir ],
#
# Whether or not to output results in "Gazebo" format.
#
#  "trenddata" : [ '' ],
#
# Whether or not to query the file size before closing it.
#
#  "statfile"  : [ '' ],
#
# Whether or not to use collective I/O for N-1, MPI/IO only.
#
#  "collective"  : [ '' ],
#
# Don't put the FS_TEST_EXTRA stuff in the database output file.
#
#  "noextra" : [ '' ],
#
# Don't put the results in the database output file.
#
#  "nodb" : [ '' ],
#
# How many seconds to sleep between write and read tests.
#
#  "sleep"  : [ 60 ],
#
# Hints to pass to the underlying file system. The only one that is used
# is Panasas' concurrent write. That is set below with the "auto_cw"
# parameter. So, you generally don't want to use this parameter.
#
#  "hints"    : [ 'panfs_concurrent_write=1' ],
#
# The type of I/O to do, N-N or N-1. Values are:
#
# 1 = N-N
# 2 = N-1
#
# We typically don't use this here, deferring this to the n1_segmented,
# n1_strided, and nn parameters below in "get_commands".
#
#  "type"  : [ 1 ],
#
# If type of I/O is N-N (1), and not PLFS (no "plfs:" in target), then
# we need to decide into how many subdirectories we want to place the
# N files. The default is 1 if the argument is not provided, and the
# files are placed directly into the target directory.
#
#  "num_nn_dirs" : [ 1 ],
#
# If type of I/O is N-N (1), and not PLFS (no "plfs:" in target), and
# num_nn_dirs is more than 1, then we need to decide on the prefix name
# for the subdirectories. The default is "nn_dir", but we can make it
# any string we want. The prefix will have a string representation of
# a number appended to it to make "num_nn_dirs" unique subdirectories.
#
#  "nn_dir_prefix" : [ 'nn_dir' ],
#
# If "type" is 2 (N-1), then this tells whether to make it strided or
# segmented. Values are:
#
# 0 = Segmented
# 1 = Strided
#
# We typically don't use this here, deferring this to the n1_segmented,
# n1_strided, and nn parameters below in "get_commands".
#
#  "strided" : [ '1' ],
}

# fs_test doesn't need program_arguments

def get_commands( expr_mgmt_options ):
  global mpi_options, mpi_program, program_options 
  return fs_test.get_commands( n1_segmented=False, n1_strided=False, nn=True, 
        mpi_options=mpi_options, mpi_program=mpi_program, auto_cw=True,
        program_options=program_options, expr_mgmt_options=expr_mgmt_options )
